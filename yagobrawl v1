<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Brawl Telegram</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            touch-action: none;
        }
        canvas {
            display: block;
            background-color: #333;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #restartBtn {
            margin-top: 15px;
            padding: 8px 15px;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="gameOver">
        <h2 id="resultText">Game Over</h2>
        <p id="placeText"></p>
        <button id="restartBtn">Play Again</button>
    </div>

    <script>
        // Game configuration
        const config = {
            width: 800,
            height: 600,
            playerSpeed: 3,
            botSpeed: 2,
            bulletSpeed: 7,
            meleeRange: 50,
            shotgunSpread: Math.PI / 6,
            playerSize: 30,
            bulletSize: 8,
            spawnProtectionTime: 2000,
            gameDuration: 120000 // 2 minutes
        };

        // Game elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameOverDiv = document.getElementById('gameOver');
        const resultText = document.getElementById('resultText');
        const placeText = document.getElementById('placeText');
        const restartBtn = document.getElementById('restartBtn');

        // Set canvas size
        canvas.width = config.width;
        canvas.height = config.height;

        // Game state
        let gameRunning = false;
        let player;
        let bots = [];
        let bullets = [];
        let particles = [];
        let lastTime = 0;
        let gameStartTime = 0;
        let playerPlace = 0;
        let selectedBrawler = 1; // Default to Shotgunner
        let spawnProtection = false;
        let spawnProtectionEndTime = 0;

        // Input state
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            w: false,
            a: false,
            s: false,
            d: false
        };

        const mouse = {
            x: 0,
            y: 0,
            click: false
        };

        // Initialize game from Telegram bot parameters
        function initGame(brawlerType) {
            selectedBrawler = brawlerType || 1;
            resetGame();
            gameRunning = true;
            gameStartTime = Date.now();
            spawnProtection = true;
            spawnProtectionEndTime = Date.now() + config.spawnProtectionTime;
            gameOverDiv.style.display = 'none';
            requestAnimationFrame(gameLoop);
        }

        // Reset game state
        function resetGame() {
            player = createPlayer(selectedBrawler);
            bots = createBots();
            bullets = [];
            particles = [];
            playerPlace = 0;
        }

        // Create player entity
        function createPlayer(brawlerType) {
            return {
                x: config.width / 2,
                y: config.height / 2,
                size: config.playerSize,
                speed: config.playerSpeed,
                health: 100,
                maxHealth: 100,
                brawlerType: brawlerType,
                lastShot: 0,
                shotDelay: brawlerType === 3 ? 500 : 1000, // Melee attacks faster
                color: getBrawlerColor(brawlerType),
                isPlayer: true,
                isDead: false,
                kills: 0,
                damageDealt: 0
            };
        }

        // Create bots
        function createBots() {
            const botCount = 9;
            const bots = [];

            for (let i = 0; i < botCount; i++) {
                // Random position (not too close to center)
                let x, y;
                do {
                    x = Math.random() * (config.width - 100) + 50;
                    y = Math.random() * (config.height - 100) + 50;
                } while (Math.abs(x - config.width/2) < 100 && Math.abs(y - config.height/2) < 100);

                // Random brawler type
                const brawlerType = Math.floor(Math.random() * 3) + 1;

                bots.push({
                    x: x,
                    y: y,
                    size: config.playerSize,
                    speed: config.botSpeed,
                    health: 100,
                    maxHealth: 100,
                    brawlerType: brawlerType,
                    lastShot: 0,
                    shotDelay: brawlerType === 3 ? 500 : 1000,
                    color: getBrawlerColor(brawlerType),
                    targetX: x,
                    targetY: y,
                    targetChangeTime: 0,
                    isPlayer: false,
                    isDead: false,
                    kills: 0,
                    damageDealt: 0
                });
            }

            return bots;
        }

        // Get color based on brawler type
        function getBrawlerColor(type) {
            switch(type) {
                case 1: return '#FF5555'; // Shotgunner - red
                case 2: return '#5555FF'; // Gunner - blue
                case 3: return '#55FF55'; // Melee - green
                default: return '#FFFFFF';
            }
        }

        // Game loop
        function gameLoop(timestamp) {
            if (!gameRunning) return;

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            update(deltaTime);
            render();

            // Check game over conditions
            const elapsedTime = Date.now() - gameStartTime;
            if (player.isDead || elapsedTime >= config.gameDuration) {
                endGame();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update(deltaTime) {
            // Update player
            if (!player.isDead) {
                updatePlayer();

                // Check spawn protection
                if (spawnProtection && Date.now() > spawnProtectionEndTime) {
                    spawnProtection = false;
                }
            }

            // Update bots
            bots.forEach(bot => {
                if (!bot.isDead) {
                    updateBot(bot);
                }
            });

            // Update bullets
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                // Check collisions with players
                checkBulletCollisions(bullet);

                // Remove bullets out of bounds
                if (bullet.x < 0 || bullet.x > config.width ||
                    bullet.y < 0 || bullet.y > config.height) {
                    bullets.splice(index, 1);
                }
            });

            // Update particles
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.lifetime -= deltaTime;

                if (particle.lifetime <= 0) {
                    particles.splice(index, 1);
                }
            });

            // Remove dead bots
            bots = bots.filter(bot => !bot.isDead);

            // Check win condition (if only player remains)
            if (bots.length === 0 && !player.isDead) {
                playerPlace = 1;
                endGame();
            }
        }

        // Update player movement and shooting
        function updatePlayer() {
            // Movement
            let dx = 0, dy = 0;

            if (keys.ArrowUp || keys.w) dy -= 1;
            if (keys.ArrowDown || keys.s) dy += 1;
            if (keys.ArrowLeft || keys.a) dx -= 1;
            if (keys.ArrowRight || keys.d) dx += 1;

            // Normalize diagonal movement
            if (dx !== 0 && dy !== 0) {
                const invSqrt = 1 / Math.sqrt(dx*dx + dy*dy);
                dx *= invSqrt;
                dy *= invSqrt;
            }

            player.x += dx * player.speed;
            player.y += dy * player.speed;

            // Keep player in bounds
            player.x = Math.max(player.size, Math.min(config.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(config.height - player.size, player.y));

            // Shooting
            if (mouse.click && Date.now() - player.lastShot > player.shotDelay) {
                player.lastShot = Date.now();

                switch(player.brawlerType) {
                    case 1: // Shotgunner - triangle spread
                        for (let i = -1; i <= 1; i++) {
                            const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x) + i * config.shotgunSpread;
                            shootBullet(player, angle);
                        }
                        break;
                    case 2: // Gunner - straight shot
                        const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                        shootBullet(player, angle);
                        break;
                    case 3: // Melee - no bullet, direct damage
                        const targets = [...bots].filter(bot => !bot.isDead);
                        targets.forEach(target => {
                            const dist = Math.sqrt((target.x - player.x)**2 + (target.y - player.y)**2);
                            if (dist < config.meleeRange) {
                                target.health -= 25;
                                player.damageDealt += 25;
                                createParticles(target.x, target.y, target.color);

                                if (target.health <= 0) {
                                    target.isDead = true;
                                    player.kills++;
                                }
                            }
                        });
                        break;
                }
            }
        }

        // Update bot AI
        function updateBot(bot) {
            // Simple AI: move randomly and shoot at nearest enemy

            // Change target periodically
            if (Date.now() > bot.targetChangeTime) {
                bot.targetX = Math.random() * config.width;
                bot.targetY = Math.random() * config.height;
                bot.targetChangeTime = Date.now() + 2000 + Math.random() * 3000;
            }

            // Move toward target
            const dx = bot.targetX - bot.x;
            const dy = bot.targetY - bot.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 10) {
                bot.x += (dx / dist) * bot.speed;
                bot.y += (dy / dist) * bot.speed;
            }

            // Keep bot in bounds
            bot.x = Math.max(bot.size, Math.min(config.width - bot.size, bot.x));
            bot.y = Math.max(bot.size, Math.min(config.height - bot.size, bot.y));

            // Find nearest enemy to shoot at
            let nearestEnemy = null;
            let minDist = Infinity;

            // Check player
            if (!player.isDead) {
                const distToPlayer = Math.sqrt((player.x - bot.x)**2 + (player.y - bot.y)**2);
                if (distToPlayer < minDist) {
                    minDist = distToPlayer;
                    nearestEnemy = player;
                }
            }

            // Check other bots
            bots.forEach(otherBot => {
                if (otherBot !== bot && !otherBot.isDead) {
                    const distToBot = Math.sqrt((otherBot.x - bot.x)**2 + (otherBot.y - bot.y)**2);
                    if (distToBot < minDist) {
                        minDist = distToBot;
                        nearestEnemy = otherBot;
                    }
                }
            });

            // Shoot at nearest enemy
            if (nearestEnemy && Date.now() - bot.lastShot > bot.shotDelay) {
                bot.lastShot = Date.now();
                const angle = Math.atan2(nearestEnemy.y - bot.y, nearestEnemy.x - bot.x);

                switch(bot.brawlerType) {
                    case 1: // Shotgunner
                        for (let i = -1; i <= 1; i++) {
                            shootBullet(bot, angle + i * config.shotgunSpread);
                        }
                        break;
                    case 2: // Gunner
                        shootBullet(bot, angle);
                        break;
                    case 3: // Melee
                        if (minDist < config.meleeRange) {
                            nearestEnemy.health -= 25;
                            bot.damageDealt += 25;
                            createParticles(nearestEnemy.x, nearestEnemy.y, nearestEnemy.color);

                            if (nearestEnemy.health <= 0) {
                                nearestEnemy.isDead = true;
                                bot.kills++;

                                // If player died, set their place
                                if (nearestEnemy.isPlayer) {
                                    playerPlace = bots.filter(b => !b.isDead).length + 1;
                                }
                            }
                        }
                        break;
                }
            }
        }

        // Create a bullet
        function shootBullet(shooter, angle) {
            const bullet = {
                x: shooter.x,
                y: shooter.y,
                vx: Math.cos(angle) * config.bulletSpeed,
                vy: Math.sin(angle) * config.bulletSpeed,
                size: config.bulletSize,
                shooter: shooter,
                damage: shooter.brawlerType === 1 ? 15 : 20 // Shotgun does less damage per pellet
            };

            bullets.push(bullet);
            createParticles(shooter.x, shooter.y, shooter.color);
        }

        // Check bullet collisions
        function checkBulletCollisions(bullet) {
            // Check player collision (if bullet not from player)
            if (!bullet.shooter.isPlayer && !player.isDead && !spawnProtection) {
                const dist = Math.sqrt((bullet.x - player.x)**2 + (bullet.y - player.y)**2);
                if (dist < player.size + bullet.size) {
                    player.health -= bullet.damage;
                    bullet.shooter.damageDealt += bullet.damage;
                    createParticles(player.x, player.y, player.color);

                    if (player.health <= 0) {
                        player.isDead = true;
                        bullet.shooter.kills++;
                        playerPlace = bots.filter(b => !b.isDead).length + 1;
                    }

                    // Remove bullet on hit
                    const index = bullets.indexOf(bullet);
                    if (index !== -1) bullets.splice(index, 1);
                    return;
                }
            }

            // Check bot collisions
            bots.forEach(bot => {
                if (!bot.isDead && bullet.shooter !== bot) {
                    const dist = Math.sqrt((bullet.x - bot.x)**2 + (bullet.y - bot.y)**2);
                    if (dist < bot.size + bullet.size) {
                        bot.health -= bullet.damage;
                        bullet.shooter.damageDealt += bullet.damage;
                        createParticles(bot.x, bot.y, bot.color);

                        if (bot.health <= 0) {
                            bot.isDead = true;
                            bullet.shooter.kills++;

                            // If player made the kill
                            if (bullet.shooter.isPlayer) {
                                player.kills++;
                            }
                        }

                        // Remove bullet on hit
                        const index = bullets.indexOf(bullet);
                        if (index !== -1) bullets.splice(index, 1);
                    }
                }
            });
        }

        // Create particles for visual effects
        function createParticles(x, y, color) {
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.random() * 4 - 2,
                    vy: Math.random() * 4 - 2,
                    size: Math.random() * 3 + 2,
                    color: color,
                    lifetime: 500 + Math.random() * 500
                });
            }
        }

        // Render game
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, config.width, config.height);

            // Draw background grid
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;

            for (let x = 0; x < config.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, config.height);
                ctx.stroke();
            }

            for (let y = 0; y < config.height; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(config.width, y);
                ctx.stroke();
            }

            // Draw bullets
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.shooter.color;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw particles
            particles.forEach(particle => {
                ctx.globalAlpha = particle.lifetime / 1000;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Draw bots
            bots.forEach(bot => {
                if (!bot.isDead) {
                    // Draw bot body
                    ctx.fillStyle = bot.color;
                    ctx.beginPath();
                    ctx.arc(bot.x, bot.y, bot.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw health bar
                    const healthWidth = (bot.size * 2) * (bot.health / bot.maxHealth);
                    ctx.fillStyle = 'red';
                    ctx.fillRect(bot.x - bot.size, bot.y - bot.size - 10, bot.size * 2, 5);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(bot.x - bot.size, bot.y - bot.size - 10, healthWidth, 5);
                }
            });

            // Draw player
            if (!player.isDead) {
                // Draw spawn protection shield
                if (spawnProtection) {
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw player body
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
                ctx.fill();

                // Draw health bar
                const healthWidth = (player.size * 2) * (player.health / player.maxHealth);
                ctx.fillStyle = 'red';
                ctx.fillRect(player.x - player.size, player.y - player.size - 10, player.size * 2, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(player.x - player.size, player.y - player.size - 10, healthWidth, 5);

                // Draw aiming line for ranged characters
                if (player.brawlerType !== 3) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(mouse.x, mouse.y);
                    ctx.stroke();
                }
            }

            // Draw UI
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Health: ${player.health}`, 10, 20);
            ctx.fillText(`Kills: ${player.kills}`, 10, 40);

            // Draw timer
            const elapsed = Date.now() - gameStartTime;
            const remaining = Math.max(0, config.gameDuration - elapsed);
            const seconds = Math.floor(remaining / 1000);
            ctx.textAlign = 'center';
            ctx.fillText(`Time: ${seconds}s`, config.width / 2, 20);

            // Draw alive count
            const aliveCount = bots.filter(b => !b.isDead).length + (player.isDead ? 0 : 1);
            ctx.fillText(`Alive: ${aliveCount}/10`, config.width / 2, 40);
        }

        // End game and show results
        function endGame() {
            gameRunning = false;

            resultText.textContent = player.isDead ? 'You Died!' : 'Game Over';
            placeText.textContent = `You placed #${playerPlace} out of 10`;

            // Calculate score to send back to Telegram bot
            const score = {
                place: playerPlace,
                kills: player.kills,
                damageDealt: player.damageDealt,
                brawlerType: player.brawlerType,
                survivalTime: Date.now() - gameStartTime
            };

            // In Telegram, this would call the game callback
            if (TelegramGameProxy && TelegramGameProxy.receiveScore) {
                TelegramGameProxy.receiveScore(JSON.stringify(score));
            }

            gameOverDiv.style.display = 'block';
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.click = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.click = false;
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.touches[0].clientX - rect.left;
            mouse.y = e.touches[0].clientY - rect.top;
            mouse.click = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.touches[0].clientX - rect.left;
            mouse.y = e.touches[0].clientY - rect.top;
        });

        canvas.addEventListener('touchend', () => {
            mouse.click = false;
        });

        restartBtn.addEventListener('click', () => {
            initGame(selectedBrawler);
        });

        // For Telegram integration
        window.TelegramGameProxy = {
            receiveEvent: function(data) {
                // Handle events from Telegram
                console.log('Received event:', data);
            },

            // This would be called by Telegram when sharing score
            shareScore: function() {
                // Implement score sharing
                console.log('Sharing score');
            }
        };

        // Initialize game when loaded in Telegram
        window.addEventListener('load', () => {
            // In Telegram, the brawler type would be passed as a parameter
            const urlParams = new URLSearchParams(window.location.search);
            const brawlerType = parseInt(urlParams.get('brawler')) || 1;

            initGame(brawlerType);
        });
    </script>
</body>
</html>
